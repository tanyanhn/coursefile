\documentclass[a4paper]{book}

\usepackage{geometry}
% make full use of A4 papers
\geometry{margin=1.5cm, vmargin={0pt,1cm}}
\setlength{\topmargin}{-1cm}
\setlength{\paperheight}{29.7cm}
\setlength{\textheight}{25.1cm}

% auto adjust the marginals
\usepackage{marginfix}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{CJKutf8}   % for Chinese characters
\usepackage{ctex}
\usepackage{enumerate}
\usepackage{graphicx}  % for figures
\usepackage{layout}
\usepackage{multicol}  % multiple columns to reduce number of pages
\usepackage{mathrsfs}  
\usepackage{fancyhdr}
\usepackage{subfigure}
\usepackage{tcolorbox}
\usepackage{tikz-cd}
\usepackage{listings}
\usepackage{xcolor} %代码高亮
\usepackage{braket}
\usepackage{algorithm} 
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}  

\floatname{algorithm}{算法}  
\renewcommand{\algorithmicrequire}{\textbf{输入:}}  
\renewcommand{\algorithmicensure}{\textbf{输出:}}  
\renewcommand{\algorithmicrequire}{\textbf{Input : }}
\renewcommand{\algorithmicrequire}{\textbf{Precondition : }}
\renewcommand{\algorithmicensure}{\textbf{Output : }}
\renewcommand{\algorithmicensure}{\textbf{Postcondition : }}
%------------------
% common commands %
%------------------
% differentiation
\newcommand{\gen}[1]{\left\langle #1 \right\rangle}
\newcommand{\dif}{\mathrm{d}}
\newcommand{\difPx}[1]{\frac{\partial #1}{\partial x}}
\newcommand{\difPy}[1]{\frac{\partial #1}{\partial y}}
\newcommand{\Dim}{\mathrm{D}}
\newcommand{\avg}[1]{\left\langle #1 \right\rangle}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\Span}{\mathrm{span}}
\newcommand{\dom}{\mathrm{dom}}
\newcommand{\Arity}{\mathrm{arity}}
\newcommand{\Int}{\mathrm{Int}}
\newcommand{\Ext}{\mathrm{Ext}}
\newcommand{\Cl}{\mathrm{Cl}}
\newcommand{\Fr}{\mathrm{Fr}}
% group is generated by
\newcommand{\grb}[1]{\left\langle #1 \right\rangle}
% rank
\newcommand{\rank}{\mathrm{rank}}
\newcommand{\Iden}{\mathrm{Id}}

% this environment is for solutions of examples and exercises
\newenvironment{solution}%
{\noindent\textbf{Solution.}}%
{\qedhere}
% the following command is for disabling environments
%  so that their contents do not show up in the pdf.
\makeatletter
\newcommand{\voidenvironment}[1]{%
\expandafter\providecommand\csname env@#1@save@env\endcsname{}%
\expandafter\providecommand\csname env@#1@process\endcsname{}%
\@ifundefined{#1}{}{\RenewEnviron{#1}{}}%
}
\makeatother

%---------------------------------------------
% commands specifically for complex analysis %
%---------------------------------------------
% complex conjugate
\newcommand{\ccg}[1]{\overline{#1}}
% the imaginary unit
\newcommand{\ii}{\mathbf{i}}
%\newcommand{\ii}{\boldsymbol{i}}
% the real part
\newcommand{\Rez}{\mathrm{Re}\,}
% the imaginary part
\newcommand{\Imz}{\mathrm{Im}\,}
% punctured complex plane
\newcommand{\pcp}{\mathbb{C}^{\bullet}}
% the principle branch of the logarithm
\newcommand{\Log}{\mathrm{Log}}
% the principle value of a nonzero complex number
\newcommand{\Arg}{\mathrm{Arg}}
\newcommand{\Null}{\mathrm{null}}
\newcommand{\Range}{\mathrm{range}}
\newcommand{\Ker}{\mathrm{ker}}
\newcommand{\Iso}{\mathrm{Iso}}
\newcommand{\Aut}{\mathrm{Aut}}
\newcommand{\ord}{\mathrm{ord}}
\newcommand{\Res}{\mathrm{Res}}
%\newcommand{\GL2R}{\mathrm{GL}(2,\mathbb{R})}
\newcommand{\GL}{\mathrm{GL}}
\newcommand{\SL}{\mathrm{SL}}
\newcommand{\Dist}[2]{\left|{#1}-{#2}\right|}

\newcommand\tbbint{{-\mkern -16mu\int}}
\newcommand\tbint{{\mathchar '26\mkern -14mu\int}}
\newcommand\dbbint{{-\mkern -19mu\int}}
\newcommand\dbint{{\mathchar '26\mkern -18mu\int}}
\newcommand\bint{
{\mathchoice{\dbint}{\tbint}{\tbint}{\tbint}}
}
\newcommand\bbint{
{\mathchoice{\dbbint}{\tbbint}{\tbbint}{\tbbint}}
}





%----------------------------------------
% theorem and theorem-like environments %
%----------------------------------------
\numberwithin{equation}{chapter}
\theoremstyle{definition}

\newtheorem{thm}{Theorem}[chapter]
\newtheorem{axm}[thm]{Axiom}
\newtheorem{alg}[thm]{Algorithm}
\newtheorem{asm}[thm]{Assumption}
\newtheorem{defn}[thm]{Definition}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{rul}[thm]{Rule}
\newtheorem{coro}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{exm}{Example}[chapter]
\newtheorem{rem}{Remark}[chapter]
\newtheorem{exc}[exm]{Exercise}
\newtheorem{frm}[thm]{Formula}
\newtheorem{ntn}{Notation}

% for complying with the convention in the textbook
\newtheorem{rmk}[thm]{Remark}


%----------------------
% the end of preamble %
%----------------------

\begin{document}
\pagestyle{plain}
\pagenumbering{roman}

%\tableofcontents
%\clearpage

%\pagestyle{fancy}
%\fancyhead{}
%\lhead{Qinghai Zhang}
%\chead{Notes on Algebraic Topology}
%\rhead{Fall 2018}


\setcounter{chapter}{0}
\pagenumbering{arabic}
% \setcounter{page}{0}


% each chapter is factored into a separate file.

\chapter{EmbeddedGrid 生成流程}

\section{c$++$类设计}
\subsection{Curve}
\subsubsection{数据成员}
\begin{enumerate}
  \item \texttt{vector<Polynomial> polys;} \\
        分段拟合的多项式样条.

  \item \texttt{vector<Real> knots;} \\
        拟合样条的knots顺序集合.
\end{enumerate}

\subsection{OrientedJordanCurve}
继承自Curve, 拥有同样的数据结构, 额外满足首尾相连.

\subsubsection{函数成员}
\begin{enumerate}
  \item \texttt{void define(vector<Vec>\& points, vector<size\_t>\& kinks);} \\
        根据输入的点points和尖点kinks集合, 拟合初始化带尖点的OrientedJordanCurve.

  \item \texttt{void split(const vector<Real> \&brks,\\
          vector<Curve> \&out, Real tol) const;} \\
        输入断点brks, 得到OrientedJordanCurve从断点剪开的Curve集合out.
\end{enumerate}

\subsection{YinSet}

\subsubsection{数据成员}
\begin{enumerate}
  \item \texttt{vector<OrientedJordanCurve> orientedJordanCurves} \\
        表示YinSet边界的JordanCurve集合.

  \item \texttt{SimplicialComplex kinks} \\
        YinSet边界上的尖点.
\end{enumerate}

\subsubsection{函数成员}
\begin{enumerate}
  \item 构造函数通过输入流, 逐个构造OrientedJordanCurve并记录尖点kinks.

  \item \texttt{void splitWithKinks(vector<Curve> \&out) const;} \\
        输出沿所有尖点剪开orientedJordanCurves得到的Curve集合.
\end{enumerate}

\subsection{BoundaryCondition}
\begin{enumerate}
  \item \texttt{static const string value[3] =
          \{"Periodic", "Neumann", "Drichlet"\};}\\
        支持的各种边界条件.

  \item \texttt{size\_t type;} \\
        当前类表示的边界条件.
\end{enumerate}

\subsection{EmbeddedGrid}
\subsubsection{内部类LabelBit}
\begin{enumerate}
  \item bdry = 0x01 标记边界cell/face.
  \item inter = 0x02 标记内部cell/face.
  \item disable = 0x04.
  \item master = 0x08
  \item slave = 0x10
  \item b\_master = 0x20
  \item b\_slave = 0x40
  \item rbdry = 0x80 标记规则边界cell/face.
  \item irrbdry = 0x100 标记不规则边界cell/face.
  \item Periodic = 0x200 标记Periodic边界条件的边界cell/face.
  \item Neumann = 0x400 标记Neumann边界条件的边界cell/face.
  \item Drichlet = 0x800 标记Drichlet边界条件的边界cell/face.
\end{enumerate}

\subsubsection{数据成员}
\begin{enumerate}
  \item \texttt{public: RectDomain<Dim>} \\
  覆盖计算区域的网格

  \item \texttt{Tensor<vector<Crv>,Dim> bdryRepo[2*Dim + 1];} \\
        存储每个cell内的边界,0-2*Dim-1对应face上的边界最后一项是cell内部的边界.

  \item \texttt{vector<iVec> difficultFaces[Dim], difficultCells, difficultBdries;} \\

  \item \texttt{Real fullVol, tinyFrac, tol;} \\
  fullVol是单个cell的体积, tinyFrac表示不被合并的最小体积, tol是计算容忍度.

  \item \texttt{Tensor<int,Dim>     cellLabel;} \\
    记录每个cell的类型bdry/inter, 如果是边界cell继续区分规则/不规则边界和各种边界条件.  

    \item  \texttt{Tensor<LinkedListNode,Dim> cellMergeInfo;} \\
    
    \item \texttt{Tensor<Real,Dim> cellVol;} \\
    记录每个cell在计算区域内部的体积.

    \item \texttt{Tensor<Crv,Dim> cellBdry;} \\
    记录每个cell中的计算区域的边界(只能有一个连通区域,否则报错).

   \item \texttt{Tensor<int,Dim>     faceLabel[Dim];} \\ 
   记录每个face的类型, 区分规则边界和不规则边界和各种边界条件.

   \item \texttt{Tensor<LinkedListNode,Dim> faceMergeInfo[Dim];} \\
  
  \item \texttt{Tensor<Real,Dim>    faceVol[Dim];} \\
    记录每个face在计算区域内的体积.

  \item \texttt{Tensor<Crv,Dim>     faceBdry[Dim];} \\
    记录每个face上的边界.

    \item \texttt{Tensor<Real,Dim>    irFaceVol;}  \\
    每个cell中不规则边界的体积.

  \item \texttt{Tensor<Crv,Dim>     irFaceBdry;} \\
    每个cell中的不规则边界.

  \item \texttt{Tensor<LinkedListNode, Dim> irMergeInfo; } \\
  
  \item \texttt{vector<iVec>        bdryCellIdx;} \\
  包含边界的cell集合.
  
  \item \texttt{vector<iVec>        bdryFaceIdx[Dim];} \\
  包含边界的face集合.
  
  \item \texttt{map<iVec, int, iVCMP> bdryCellIdxInv; } \\
  bdryCellIdx的逆运算.
  
  \item \texttt{Tensor<int, Dim>    nodeLabel;} \\
  记录网格中在计算区域内部的网格点.

\end{enumerate}

\subsubsection{函数成员}
\begin{enumerate}
  \item \texttt{EmbeddedGrid(const RectDomain<Dim> \&aDomain,
  const YinSet<Dim, Order> \&y, \\
  const vector<BoundaryCondition> \&bc,
  Real aTinyFrac,
  Real aTol)} \\
  初始化函数
  \begin{itemize}
    \item aDomain是覆盖计算区域的网格.
    \item y是计算区域YinSet.
    \item bc是YinSet边界上的边界条件.(满足与y.split输出的Curve集合一一对应.)
    \item aTinyFrac是不需要合并的cell的体积下限.
    \item aTol是计算容忍度.
  \end{itemize}

\end{enumerate}

\section{EmbeddedGrid初始化过程}
\subsection{构造OrientedJordanCurve}
调用define输入拟合的\texttt{points}和尖点\texttt{kinks}进行初始化.

\subsection{构造YinSet}
输入已经初始化的OrientedJordanCurve集合和尖点的下标集合构造函数初始化\texttt{YinSet y}.

\subsection{构造BoundaryCondition}
根据YinSet::split输出的Curve集合上的边界条件,构造\texttt{vector<BoundaryCondition> bc}.

\subsection{构造EmbeddedGrid}
\texttt{YinSet y}生成恰当的计算网格\texttt{aDomain}, 设定\texttt{aTinyFrac, aTol}. 调用构造函数.


\end{document}
