\documentclass[a4paper]{book}

\usepackage{geometry}
% make full use of A4 papers
\geometry{margin=1.5cm, vmargin={0pt,1cm}}
\setlength{\topmargin}{-1cm}
\setlength{\paperheight}{29.7cm}
\setlength{\textheight}{25.1cm}

% auto adjust the marginals
\usepackage{marginfix}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{CJKutf8}   % for Chinese characters
\usepackage{ctex}
\usepackage{enumerate}
\usepackage{graphicx}  % for figures
\usepackage{layout}
\usepackage{multicol}  % multiple columns to reduce number of pages
\usepackage{mathrsfs}  
\usepackage{fancyhdr}
\usepackage{subfigure}
\usepackage{tcolorbox}
\usepackage{tikz-cd}
\usepackage{listings}
\usepackage{xcolor} %代码高亮
\usepackage{braket}
\usepackage{algorithm} 
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}  
\usepackage{multirow}

\floatname{algorithm}{算法}  
\renewcommand{\algorithmicrequire}{\textbf{输入:}}  
\renewcommand{\algorithmicensure}{\textbf{输出:}}  
\renewcommand{\algorithmicrequire}{\textbf{Input : }}
\renewcommand{\algorithmicrequire}{\textbf{Precondition : }}
\renewcommand{\algorithmicensure}{\textbf{Output : }}
\renewcommand{\algorithmicensure}{\textbf{Postcondition : }}
%------------------
% common commands %
%------------------
% differentiation
\newcommand{\gen}[1]{\left\langle #1 \right\rangle}
\newcommand{\dif}{\mathrm{d}}
\newcommand{\difPx}[1]{\frac{\partial #1}{\partial x}}
\newcommand{\difPy}[1]{\frac{\partial #1}{\partial y}}
\newcommand{\Dim}{\mathrm{D}}
\newcommand{\avg}[1]{\left\langle #1 \right\rangle}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\Span}{\mathrm{span}}
\newcommand{\dom}{\mathrm{dom}}
\newcommand{\Arity}{\mathrm{arity}}
\newcommand{\Int}{\mathrm{Int}}
\newcommand{\Ext}{\mathrm{Ext}}
\newcommand{\Cl}{\mathrm{Cl}}
\newcommand{\Fr}{\mathrm{Fr}}
% group is generated by
\newcommand{\grb}[1]{\left\langle #1 \right\rangle}
% rank
\newcommand{\rank}{\mathrm{rank}}
\newcommand{\Iden}{\mathrm{Id}}

% this environment is for solutions of examples and exercises
\newenvironment{solution}%
{\noindent\textbf{Solution.}}%
{\qedhere}
% the following command is for disabling environments
%  so that their contents do not show up in the pdf.
\makeatletter
\newcommand{\voidenvironment}[1]{%
\expandafter\providecommand\csname env@#1@save@env\endcsname{}%
\expandafter\providecommand\csname env@#1@process\endcsname{}%
\@ifundefined{#1}{}{\RenewEnviron{#1}{}}%
}
\makeatother

%---------------------------------------------
% commands specifically for complex analysis %
%---------------------------------------------
% complex conjugate
\newcommand{\ccg}[1]{\overline{#1}}
% the imaginary unit
\newcommand{\ii}{\mathbf{i}}
%\newcommand{\ii}{\boldsymbol{i}}
% the real part
\newcommand{\Rez}{\mathrm{Re}\,}
% the imaginary part
\newcommand{\Imz}{\mathrm{Im}\,}
% punctured complex plane
\newcommand{\pcp}{\mathbb{C}^{\bullet}}
% the principle branch of the logarithm
\newcommand{\Log}{\mathrm{Log}}
% the principle value of a nonzero complex number
\newcommand{\Arg}{\mathrm{Arg}}
\newcommand{\Null}{\mathrm{null}}
\newcommand{\Range}{\mathrm{range}}
\newcommand{\Ker}{\mathrm{ker}}
\newcommand{\Iso}{\mathrm{Iso}}
\newcommand{\Aut}{\mathrm{Aut}}
\newcommand{\ord}{\mathrm{ord}}
\newcommand{\Res}{\mathrm{Res}}
%\newcommand{\GL2R}{\mathrm{GL}(2,\mathbb{R})}
\newcommand{\GL}{\mathrm{GL}}
\newcommand{\SL}{\mathrm{SL}}
\newcommand{\Dist}[2]{\left|{#1}-{#2}\right|}

\newcommand\tbbint{{-\mkern -16mu\int}}
\newcommand\tbint{{\mathchar '26\mkern -14mu\int}}
\newcommand\dbbint{{-\mkern -19mu\int}}
\newcommand\dbint{{\mathchar '26\mkern -18mu\int}}
\newcommand\bint{
{\mathchoice{\dbint}{\tbint}{\tbint}{\tbint}}
}
\newcommand\bbint{
{\mathchoice{\dbbint}{\tbbint}{\tbbint}{\tbbint}}
}





%----------------------------------------
% theorem and theorem-like environments %
%----------------------------------------
\numberwithin{equation}{chapter}
\theoremstyle{definition}

\newtheorem{thm}{Theorem}[chapter]
\newtheorem{axm}[thm]{Axiom}
\newtheorem{alg}[thm]{Algorithm}
\newtheorem{asm}[thm]{Assumption}
\newtheorem{defn}[thm]{Definition}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{rul}[thm]{Rule}
\newtheorem{coro}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{exm}{Example}[chapter]
\newtheorem{rem}{Remark}[chapter]
\newtheorem{exc}[exm]{Exercise}
\newtheorem{frm}[thm]{Formula}
\newtheorem{ntn}{Notation}

% for complying with the convention in the textbook
\newtheorem{rmk}[thm]{Remark}


%\lstset{
%	backgroundcolor=\color{red!50!green!50!blue!50},%代码块背景色为浅灰色
%	rulesepcolor= \color{gray}, %代码块边框颜色
%	breaklines=true,  %代码过长则换行
%	numbers=left, %行号在左侧显示
%	numberstyle= \small,%行号字体
%	keywordstyle= \color{blue},%关键字颜色
%	commentstyle=\color{gray}, %注释颜色
%	frame=shadowbox%用方框框住代码块
%}
\lstset{
columns=fixed,       
numbers=left,                                        % 在左侧显示行号
numberstyle=\tiny\color{gray},                       % 设定行号格式
frame=none,                                          % 不显示背景边框
backgroundcolor=\color[RGB]{245,245,244},            % 设定背景颜色
keywordstyle=\color[RGB]{40,40,255},                 % 设定关键字颜色
numberstyle=\footnotesize\color{darkgray},           
commentstyle=\it\color[RGB]{0,96,96},                % 设置代码注释的格式
stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},   % 设置字符串格式
showstringspaces=false,                              % 不显示字符串中的空格
language=c++,                                        % 设置语言
}

%----------------------
% the end of preamble %
%----------------------

\begin{document}
\pagestyle{empty}
\pagenumbering{roman}

%\tableofcontents
%\clearpage

%\pagestyle{fancy}
%\fancyhead{}
%\lhead{Qinghai Zhang}
%\chead{Notes on Algebraic Topology}
%\rhead{Fall 2018}


\setcounter{chapter}{0}
\pagenumbering{arabic}
% \setcounter{page}{0}

% --------------------------------------------------------
% uncomment the following to remove these environments 
%  to generate handouts for students.
% --------------------------------------------------------
% \begingroup
% \voidenvironment{rem}%
% \voidenvironment{proof}%
% \voidenvironment{solution}%


% each chapter is factored into a separate file.

\chapter{空间划分法优化YinSet布尔运算中的三角形求交}
已有算法使用的两个YinSet中所有的三角形两两求交,该文档
在不改变三角形求交算法接口的前提下,设计使用空间划分法减少
计算三角形求交的次数来提高YinSet布尔运算的运行效率.

以下实现类和函数都在名字空间YSB中.
\section{算法接口: 契约}
\subsubsection{调用函数}
void TriangleIntersection::operator()(
const std::vector<Triangle>\& inputA,
const std::vector<Triangle>\& inputB,
Real tol)
\subsubsection{输入}
inputA, inputB分别是两个YinSet边界上的所有三角形.
\subsubsection{输入条件}
一个YinSet内的三角形不交或交于边和顶点.
\subsubsection{输出}
TriangleIntersection的成员变量
vector<pair<vector<Segment>,
vector<pair<int, int>\!>\!>\!> resultA, resultB;

inputA中第i个三角形inputA[i]与其他所有三角形的交线段存放在resultA[i].first,
所有重合三角形存放在resultA[i].second.
resultA[i].first中的线段保存了是哪两个三角形相交得到. resultB类似.

\section{代码实现}
\subsection{Cuboid}
\subsubsection{模板: template<int T>}
T 表示空间坐标使用的数据类型.

\subsubsection{功能}
三维空间中的长方体,用于将三角形区分为与长方体有公共部分和没有公共部分两类.

\subsubsection{数据成员}
\begin{enumerate}
  \item Point<T, 3> vertex[8]: 长方体的8个顶点.
  \item Rectangle<T, 3> face[6]: 长方体的6张面.
\end{enumerate}

\subsubsection{函数成员}
\begin{enumerate}
  \item int contain(Point<T, 3> p, Real tol = TOL) const: \\
        \textbf{输入: }一个点Point p. \\
        \textbf{输出: }长方体是否包含p.

  \item vector<Cuboid<T>\!> divide() const: \\
        \textbf{输出: }长方体8等分得到的8个长方体.

  \item void intersect(const Triangle<T, 3>\& tri,
        vector<int>\& res,
        Real tol = TOL) const: \\
        \textbf{输入: }一个点Triangle tri. \\
        \textbf{输出: }8等分得到的长方体分别与tri是否相交.
\end{enumerate}

\subsection{OctreeNode}

\subsubsection{功能}
树节点,存储节点包含的三角形,空间划分树确定后计算所有叶节点中的三角形求交.

\subsubsection{数据成员}
\begin{enumerate}
  \item Cuboid val: 节点对应的长方体.
  \item vector<OctreeNode*>: 8等分的子长方体对应的节点.
  \item vector<int> tris[2]: 包含的YinSet中的三角形.
\end{enumerate}

\subsection{OctreeTriangleIntersection}
\subsubsection{模板: template<int T>}
T 表示空间坐标使用的数据类型.

\subsubsection{功能}
计算布尔运算时的三角形求交.

\subsubsection{数据成员}
\begin{enumerate}
  \item public TriangleIntersection<T>: 继承三角形求交的接口.
  \item OctreeNode<Cuboid<T>>* root: 计算区域的空间划分树的根节点.
  \item int deep: 空间划分树的最大深度,默认为log(n).
\end{enumerate}

\subsubsection{函数成员}
\begin{enumerate}
  \item void initOctree(const vector<Triangle<T, 3>\!>\& inputA,
        const vector<Triangle<T, 3>\!>\& inputB,
        int depth,
        Real tol): \\
        \textbf{输入: }计算求交的所有三角形和树的最大深度. \\
        \textbf{输出: }空间划分树的根节点root,树内每个节点存储了与节点
        对应的长方体有公共部分的三角形.

  \item virtual long testNum(OctreeNode<Cuboid<T>\!>* r)  const: \\
        \textbf{输入: }空间划分树的一个节点r. \\
        \textbf{输出: }节点r中需要计算的三角形求交次数.

  \item void dfsConstructTree(OctreeNode<Cuboid<T>\!>* r,
        int depth,
        const std::vector<Triangle<T, 3>\!>\& inputA,
        const std::vector<Triangle<T, 3>\!>\& inputB) \\
        \textbf{输入: }空间划分树的一个叶节点,剩余深度. \\
        \textbf{输出: }若没有达到最大深度并且testNum()不返回0,
        构造当前节点对应长方体的8等分作为叶节点,并根据相交关系将当前
        节点包含的三角形分配到叶节点中.最后对叶节点递归调用函数.

  \item int pruneTree(OctreeNode<Cuboid<T>>* r): \\
        \textbf{输入: }空间划分树. \\
        \textbf{输出: }以减少计算三角形求交数量为目标对树进行剪枝.

  \item void calTest(OctreeNode<Cuboid<T>\!>* r,
        const vector<Triangle<T, 3>\!>\& inputA,
        const vector<Triangle<T, 3>\!>\& inputB,
        Real tol): \\
        \textbf{输入: }空间划分树,求交的三角形. \\
        \textbf{输出: }对每个叶节点中的三角形进行求交.

  \item void edgeCal(const vector<Triangle<T, 3>\!>\& input,
        Real tol, int id): \\
        \textbf{输入: }一个YinSet的三角形. \\
        \textbf{输出: }三角形之间在边上的相交关系.

  \item void intersect(
        int iA,
        int iB,
        const vector<Triangle<T, 3>\!>\& inputA,
        const vector<Triangle<T, 3>\!>\& inputB,
        Real tol):  \\
        \textbf{输入: }求交的两个三角形. \\
        \textbf{输出: }在三角形对应的resultA, resultB中新增求交结果.
\end{enumerate}


\end{document}
